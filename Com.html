<!DOCTYPE html>
<html lang="fr">
  <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>TD's Portfolio</title>
    
    <!--FavIcon-->
    <link rel="icon" type="image/png" href="Documents/favicons/icons8-accueil-40.png">
    <!--FavIcon-->

    <!--CSS Style Sheet-->
    <link rel="stylesheet" href="Com.css">
    <!--CSS Style Sheet-->

    <!--Prism-->
    <link href="Documents/Prism/prism.css" rel="stylesheet" />
    <script src="Documents/Prism/prism.js"></script>
    <!--Prism-->

    <!--Icons-->
    <script src="https://kit.fontawesome.com/2f326c2d90.js" crossorigin="anonymous"></script>
    <!--Icons-->

    <!-- FONTS -->
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Cuprum&display=swap" rel="stylesheet">
    <!-- FONTS -->
  </head>

  <body>
    
    <!--/////////////////////HEADER////////////////////////////////////////////-->
    <header>
      <a href="QuiSuisJe2.html" class="HeaderTitle"><h1>Tanguy Delage</h1></a>

      <nav class="HeaderNav">
        <a href="Index2.html" class="NavChoice">Accueil</a>
        <a href="APropos2.html" class="NavChoice">À propos</a>
        <div class="Contacts">
          <a href="#ModalContacts" class="ContactsHead">Contacts</a>
          <ul class="DropDown">
            <li>
              <a href="https://www.linkedin.com/in/tanguy-delage-a085931a0/">
                <i class="fab fa-linkedin"></i>
              </a>
            </li>
            <li>
              <a href="mailto:tanguy.delage@viacesi.fr">
                <i class="fas fa-envelope"></i>
              </a>
            </li>
            <li>
              <a href="#ModalContacts">
                <i class="fas fa-phone-square"></i>
              </a>
            </li>

          </ul>
        </div>
      </nav>
    </header>
    <!--//////////////////////HEADER///////////////////////////////////////////-->

    <!-- ///////////////////Corp du site///////////////////////////////////////-->
    <main>
        <h2>LOGO | Projet Communication</h2>
        <article>
            <section class="Intro">
                <p>
                    Nous devons faire communiquer deux ordinateurs avec du son sans que personne ne l'entende. Le premier ordinateur envoie des ultrasons qui traverse un mur pour ensuite être capté par un micro. Ce micro est relié par un réseau filaire à l'ordinateur receveur du message.
                    <br><br>
                    Le projet dans son ensemble m'a permis d'apprendre : <br>
                    - Les modulations d'onde (ici sonore), fréquence, amplitude et phase. <br>
                    - Les filtres sonores. <br>
                    - Les bases des protocoles réseaux. <br>
                    - Les bases du langage python. <br>
                    <br>
                  </p>
            </section>
            
            <section class="Content">
                <h3 id="modu">Modulations</h3>
                <section id="modup">
                    <p>
                        La modulation du son nous permet de transmettre des bits de données. Nous avons 4 modulations d'amplitude sur 2 bits et 2 modulations de phases sur 1 bit. Ainsi chaque période d'un signal envoie 3 bits de données. Nous envoyons 3 signaux en même temps qui sont portés par une onde ultrasonore. Nous avions donc un débit théorique d'envoi de 72 kbits/s. <br>
                        l'image ci-dessous récapitule l'encodage d'un signal sonore.
                    </p>
                    <h4>Tableau de correspondance bits/modulations</h4>
                    <img src="images/Com/BitsTransmis.JPG" alt="Encodage d'un signal sonore">
                </section>
      
                <h3 id="prot">Protocoles réseaux</h3>
                <section id="protp">
                    <p>
                        Le protocole réseau nous permet bien identifier chaque portion de signal à décoder et permet aussi de détecter des erreurs de transmissions potentielles. Pour identifier chaque trame nous avons un bit de start, un bit de stop, un identificateur avec le numéro de trame, un bit de parité et finalement le segment. Le segment qui contient la donnée avec le code correcteur de Hamming par-dessus pour détecter les erreurs.<br>
                        l'image ci-dessous récapitule la composition d'une trame.<br>
                    </p>
                    <h4>Modélisation de l'encapsulement d'une donnée</h4>
                    <img src="images/Com/ProtocoleReseau.JPG" alt="Composition d'une trame">
                </section>
      
                <h3 id="prog">Programme en Python</h3>
                <section id="progp">
                    <p>
                        Le programme en python nous permet de simuler l'envoie et la réception des données. c'est pourquoi nous avons un programme pour l'envoi et un autre pour la réception. <br>
            
                        Le programme d'envoi va lire le message depuis un fichier texte et faire la conversion des caractères en binaires. il va ensuite découper la suite de bits pour obtenir des segments en y rajoutant les bits de contrôles de Hamming. Le programme va composer les trames comme vu plus haut. Enfin le programme va composer le signal sonore modulé et lire le son produit. <br>
                        Voici le programme d'envoie complet.
                    </p>
                    <a href="#modal1">Programme d'envoi</a>
                    <p>
                        Dans un souci nous n'avons pas pu travailler sur la réception du son par un ordinateur, Nous avons donc simulé en écrivant les trames dans un fichier texte. <br>
            
                        Le programme de réception va lire le fichier texte avec les trames envoyées, et reconvertir les bits en caractères. Le programme passe évidemment par la décomposition des trames ainsi que de tous les bits de contrôles.<br>
                        Voici le programme de réception complet.
                    </p>
                    <a href="#modal2">Programme de réception</a>
                </section>
            </section>
        </article>
    </main>
    <!-- ///////////////////Corp du site///////////////////////////////////////-->
    
    <!-- ///////////////////FOOTER/////////////////////////////////////////////-->   
    <footer>
        <button onclick="window.location.href = '#ModalContacts';">Contactez Moi</button>
        <section id="inspired">
            <p>© 2021 par Tanguy Delage. Inspiré de</p>
            <a href="https://www.reutchen.com" id="Reut">Reut Chen</a>
        </section>
        <section class="FooterLinks">
            <a href="https://icones8.fr/icons/set/favicon">Favicon de Icons8</a>
            <a href="https://fontawesome.com">Icones de Font Awesome</a>
            <a href="https://pixabay.com/fr/">Images de Pixabay</a>
            <a href="https://fonts.google.com">Polices de Google Fonts</a>
        </section>
    </footer>
    <!-- ///////////////////FOOTER/////////////////////////////////////////////-->  
    
    
    <div class="CodeBlock" id="modal1">
        <pre class="Preformate">
            <a href="#" class="ModalClose"><i class="far fa-times-circle"></i></a>
          <code class="language-py">
            #coding:utf-8
            #///////////////////////IMPORT DES MODULES////////////////////////////////////////////////////////
            import pygame
            import wave
            import math
            import binascii
            import socket
            import time

            #//////////////////////////////PARTIE SOCKET///////////////////////////////////////////////////////

            host, port = ('localhost',5566)

            socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)

            #/////////////////////COMPOSITION DES TRAMES//////////////////////////////////////////////////////

            def decoupage(sequence,nb): # découpage de la données en octets

                sequence = str(sequence)
                segments = []

                while len(sequence)%nb != 0:
                    sequence = sequence + '0'
                    print("WARNING, ajout de bit de bourrage")

                for i in range(0,len(sequence),nb):
                    segments.append(sequence[i:i+nb])

                return segments

            def hamming(decoupage): # ajout du code correcteur de hamming sur nos octets

                if type(decoupage) != list:
                    tmp = []
                    for i in range(len(decoupage)):
                        tmp.append(int(decoupage[i]))
                    decoupage = tmp

                decoupage.insert(0,1) # insertion bit de contôle 1
                decoupage.insert(1,1) # insertion bit de contrôle 2
                decoupage.insert(3,1) #insertion bit de contrôle 4
                decoupage.insert(7,1) # insertion bit de control 8

                if (decoupage[2]+decoupage[4]+decoupage[6]+decoupage[8]+decoupage[10])%2 == 0:
                    decoupage[0] = 0

                if (decoupage[2]+decoupage[5]+decoupage[6]+decoupage[9]+decoupage[10])%2 == 0:
                    decoupage[1] = 0

                if (decoupage[4]+decoupage[5]+decoupage[6]+decoupage[11])%2 == 0:
                    decoupage[3] = 0

                if (decoupage[8]+decoupage[9]+decoupage[10]+decoupage[11])%2 == 0:
                    decoupage[7] = 0

                return decoupage

            def numeroDeTrame(data,donnee):

                number = 0

                while 2**number < len(donnee)/8:
                    number +=1

                liste = list(data)
                n=2**number
                x = bin(n)[2:]
                c = bin(b)[2:]

                liste_a = list(c)
                liste.insert(0,c)

                chaine = ''.join(str(i) for i in liste)
                chaine = chaine.zfill((len(data)+number))
                return list(chaine)

            def rs232(hamming): # application du protocole rs232 + ajout N° de trame

                hamming.insert(len(hamming)+2,0)     # ajout du bit de parité
                if hamming.count(1)%2 == 0:
                    hamming[-1] = 0
                else:
                    hamming[-1] = 1

                hamming.insert(0,1)                  # ajout du bit de start
                hamming.insert(len(hamming)+2,1)     # ajout du bit de stop

                if hamming[1] == '1':
                    hamming[0] = 0
                elif hamming[1] == '0':
                    hamming[0] = 1

                if hamming[-2] == '1':
                    hamming[-1] = 0
                elif hamming[-2] == '0':
                    hamming[-1] = 1

                hamming = ''.join(str(i) for i in hamming)
                return hamming

            def StrBin(texte):

                binaire = []
                for n in texte:
                    binaire.insert(len(binaire)+1,bin(ord(n))[2:])

                    while len(binaire[-1]) < 8:
                        binaire[-1] = '0' + binaire[-1]

                binaire = ''.join(binaire)
                return binaire

            #programme principal
            config = open("E:/CESI/Projet/ondes/LeCode/config.txt","r")
            texte = config.read()
            print("\nVotre texte est : ",texte)
            texte = StrBin(texte)

            segments = decoupage(texte,8)
            b = 1
            for t in range(len(segments)):

                segments[t] = hamming(segments[t])
                segments[t] = numeroDeTrame(segments[t],texte)
                segments[t] = rs232(segments[t])
                print("\n",segments[t])
                b +=1
            try:
                socket.connect((host,port))
                print("\nvous êtes connecté au serveur ;")
                data = ' '.join(segments)
                data = data.encode("utf8")
                socket.sendall(data)
            except:
                print("\nconnexion au serveur échouée :(")
            finally:
                socket.close()

            #///////////////////////////PARTIE GÉNÉRATION DU SON/////////////////////////////////////////

            Donnee = ''.join(segments)
            TroisBits = decoupage(Donnee,3)

            print("\nCréation d'un fichier audio au format WAV (PCM 8 bits mono 8000 Hz)")

            NomFichier = 'son.wav'
            Monson = wave.open(NomFichier,'w') # instanciation de l'objet Monson

            nbCanal = 1    # mono
            nbOctet = 1    # taille d'un échantillon : 1 octet = 8 bits
            fech = 8000   # fréquence d'échantillonnage

            frequence = float(input('\nFréquence du son(Hz) ? '))
            niveau = 1              #float(input('Niveau du son du canal de gauche (0 à 1) ? '))

            nbEchantillon = int(len(Donnee)/3)

            parametres = (nbCanal,nbOctet,fech,nbEchantillon,'NONE','not compressed')# tuple
            Monson.setparams(parametres)    # création de l'en-tête (44 octets)

            print('\nVeuillez patienter...')

            amplitude = 0
            phi = 0

            for i in range(0,nbEchantillon):

                if TroisBits[i][2] == '0':     #####################
                    phi = 0                  # Modulation de Phase
                else:
                    phi = math.pi/2          #####################

                if TroisBits[i][0:2] == '00':            ###########################
                    amplitude = 127.5*niveau*0.25
                elif TroisBits[i][0:2] == '01':
                    amplitude = 127.5*niveau*0.5       # Modulation d'amplitude
                elif TroisBits[i][0:2] == '10':
                    amplitude = 127.5*niveau*0.75
                elif TroisBits[i][0:2] == '11':
                    amplitude = 127.5*niveau*1.0       ############################


                valG = wave.struct.pack('B',int(128+amplitude*math.sin(2.0*math.pi *frequence *i/fech + phi)))
                Monson.writeframes(valG) # écriture frame

            Monson.close()

            print("\nFichier son crée.\nNombre d'échantillons : {}\nFréquence d'échantillonage : {}\nDurée du son : {}".format(nbEchantillon,fech,nbEchantillon/fech))

            #//////////////////////////PARTIE LECTURE DU SON////////////////////////////////////////////////////////////////////////////

            pygame.mixer.init()
            pygame.mixer.Sound("son.wav").play()
            while pygame.mixer.get_busy():
                # lecture en cours
                pass



            time.sleep(500)
          </code>
        </pre>
    </div>

    <div class="CodeBlock" id="modal2">
        <pre class="Preformate">
            <a href="#" class="ModalClose"><i class="far fa-times-circle"></i></a>
            <code class="language-py">
                #coding:utf-8
                import time


                code = open("E:/CESI/Projet/ondes/LeCode/data.txt",'r')
                LeCode = code.read()

                def number(donnee):
                    del donnee[1:-14]

                    return donnee

                def trame(number):
                    number.pop(0)
                    number.pop(-1)
                    number.pop(-1)

                    return number


                def octet(trame):

                    trame.pop(0)
                    trame.pop(0)
                    trame.pop(1)
                    trame.pop(4)
                    trame = ''.join(trame)

                    return trame

                LeCode = LeCode.split()
                print(LeCode)
                tampon = []

                for n in range(len(LeCode)):
                    LeCode[n] = list(LeCode[n])
                    tampon.append(octet(trame(number(LeCode[n]))))

                LeCode = tampon

                print("\n",LeCode)

                decimal = []

                for n in range(len(LeCode)):
                    LeCode[n] = list(LeCode[n])
                    tampon = 0
                    puissance = 7

                    for m in range(len(LeCode[n])):

                        if LeCode[n][m] == '1':
                            tampon += 2**puissance

                        puissance = puissance - 1
                    decimal.append(chr(tampon))

                decimal = ''.join(decimal)
                print("\n",decimal)


                time.sleep(500)
            </code>
        </pre>
    </div>

  </body>
</html>